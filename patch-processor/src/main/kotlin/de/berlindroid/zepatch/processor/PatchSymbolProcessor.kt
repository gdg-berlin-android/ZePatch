package de.berlindroid.zepatch.processor

import com.google.devtools.ksp.KspExperimental
import com.google.devtools.ksp.getAnnotationsByType
import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.processing.SymbolProcessorEnvironment
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSFunctionDeclaration
import com.google.devtools.ksp.validate
import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.LambdaTypeName
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.asTypeName
import de.berlindroid.zepatch.annotations.Patch

class PatchSymbolProcessor(environment: SymbolProcessorEnvironment) : SymbolProcessor {
    private val codeGenerator: CodeGenerator = environment.codeGenerator

    @OptIn(KspExperimental::class)
    override fun process(resolver: Resolver): List<KSAnnotated> {
        val patchAnnotation = Patch::class
        val symbols = resolver.getSymbolsWithAnnotation(patchAnnotation.qualifiedName!!).toList()

        val patchFunctions =
            symbols.filterIsInstance<KSFunctionDeclaration>().filter { it.validate() }

        if (patchFunctions.isEmpty()) return emptyList()

        // Build map entries
        val entries = patchFunctions.map { funDecl ->
            val pkgName = funDecl.packageName.asString()
            val simpleName = funDecl.simpleName.asString()
            val ann = funDecl.getAnnotationsByType(Patch::class).firstOrNull()
            val key = ann?.name?.takeIf { it.isNotBlank() } ?: simpleName

            val fqName = "$pkgName.$simpleName"
            MapEntry(key, fqName)
        }

        generateRegistry(entries)
        return emptyList()
    }

    private fun generateRegistry(entries: List<MapEntry>) {
        val packageName = "de.berlindroid.zepatch.generated"
        val objectName = "PatchRegistry"
        val composableAnnotation = ClassName("androidx.compose.runtime", "Composable")

        val mapType = com.squareup.kotlinpoet.MAP.parameterizedBy(
            String::class.asTypeName(),
            LambdaTypeName.get(returnType = Unit::class.asTypeName()).copy(
                annotations = listOf(AnnotationSpec.builder(composableAnnotation).build())
            )
        )

        val mapInitializer = CodeBlock.builder().apply {
            add("mapOf(\n")
            entries.forEachIndexed { idx, e ->
                val sep = if (idx < entries.size - 1) "," else ""
                add("    %S to { %L() }%L\n", e.key, e.fqFunctionCall, sep)
            }
            add(")")
        }.build()

        val property = PropertySpec.builder("patchables", mapType, KModifier.PUBLIC)
            .initializer(mapInitializer)
            .build()

        val type = TypeSpec.objectBuilder(objectName)
            .addKdoc("Generated by KSP. Do not modify.")
            .addProperty(property)
            .build()

        val file = FileSpec.builder(packageName, objectName)
            .addType(type)
            .build()

        val fileBytes = file.toString().toByteArray()
        codeGenerator.createNewFile(
            Dependencies(aggregating = true, *emptyArray()),
            packageName,
            objectName
        ).use { out ->
            out.write(fileBytes)
        }
    }

    data class MapEntry(val key: String, val fqFunctionCall: String)
}
