package de.berlindroid.zepatch.processor

import com.google.devtools.ksp.KspExperimental
import com.google.devtools.ksp.getAnnotationsByType
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.processing.SymbolProcessorEnvironment
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSFunctionDeclaration
import com.google.devtools.ksp.validate
import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.LambdaTypeName
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.asTypeName
import de.berlindroid.zepatch.annotations.Patch

class PatchSymbolProcessor(val environment: SymbolProcessorEnvironment) : SymbolProcessor {

    @OptIn(KspExperimental::class)
    override fun process(resolver: Resolver): List<KSAnnotated> {
        val patchAnnotation = Patch::class
        val symbols = resolver.getSymbolsWithAnnotation(patchAnnotation.qualifiedName!!).toList()

        val patchFunctions =
            symbols.filterIsInstance<KSFunctionDeclaration>().filter { it.validate() }
        if (patchFunctions.isEmpty()) return emptyList()

        environment.logger.info(">>> Found ${symbols.size} symbols with @Patch annotation.")
        // Build map entries
        val entries = patchFunctions.map { funDecl ->
            val containingFile = funDecl.containingFile
            containingFile?.let {
                environment.logger.info(
                    ">>> Processing @Patch function '${funDecl.qualifiedName?.asString()}' " +
                            "found in file: ${it.filePath}"
                )
            }
            val pkgName = funDecl.packageName.asString()
            val simpleName = funDecl.simpleName.asString()
            val ann = funDecl.getAnnotationsByType(Patch::class).firstOrNull()
            val key = ann?.name?.takeIf { it.isNotBlank() } ?: simpleName

            val fqName = "$pkgName.$simpleName"
            MapEntry(key, fqName)
        }

        generateRegistry(entries)
        return emptyList()
    }

    private fun generateRegistry(entries: List<MapEntry>) {
        val packageName = "de.berlindroid.zepatch.generated"
        val objectName = "PatchRegistry"
        val composableAnnotation = ClassName("androidx.compose.runtime", "Composable")

        val imageBitmapClass = ClassName("androidx.compose.ui.graphics", "ImageBitmap")
        val onBitmapLambda = LambdaTypeName.get(
            returnType = Unit::class.asTypeName(),
            parameters = arrayOf(imageBitmapClass)
        )
        val patchableLambda = LambdaTypeName.get(
            returnType = Unit::class.asTypeName(),
            parameters = arrayOf(Boolean::class.asTypeName(), onBitmapLambda)
        ).copy(
            annotations = listOf(AnnotationSpec.builder(composableAnnotation).build())
        )

        val mapType = com.squareup.kotlinpoet.MAP.parameterizedBy(
            String::class.asTypeName(),
            patchableLambda
        )

        val mapInitializer = CodeBlock.builder().apply {
            add("mapOf(\n")
            entries.forEachIndexed { idx, e ->
                val sep = if (idx < entries.size - 1) "," else ""
                add(
                    "    %S to { shouldCapture, onBitmap -> %L(shouldCapture = shouldCapture, onBitmap = onBitmap) }%L\n",
                    e.key,
                    e.fqFunctionCall,
                    sep
                )
            }
            add(")")
        }.build()

        val property = PropertySpec.builder("patchables", mapType, KModifier.PUBLIC)
            .initializer(mapInitializer)
            .build()

        val type = TypeSpec.objectBuilder(objectName)
            .addKdoc("Generated by KSP. Do not modify.")
            .addProperty(property)
            .build()

        val file = FileSpec.builder(packageName, objectName)
            .addType(type)
            .build()

        val fileBytes = file.toString().toByteArray()
        environment.codeGenerator.createNewFile(
            Dependencies(aggregating = true, *emptyArray()),
            packageName,
            objectName
        ).use { out ->
            out.write(fileBytes)
        }
    }

    data class MapEntry(val key: String, val fqFunctionCall: String)
}
